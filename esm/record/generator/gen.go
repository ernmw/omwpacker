//go:build ignore
// +build ignore

package main

import (
	"embed"
	_ "embed"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

func fourCC(s string) string {
	s = strings.ToUpper(s)
	if len(s) > 4 {
		return s[:4]
	}

	return s + strings.Repeat("_", 4-len(s))
}

var funcMap = template.FuncMap{"fourCC": fourCC}

//go:embed *.template
var templateFiles embed.FS

func loadTemplates() (map[string]*template.Template, error) {
	templates := map[string]*template.Template{}
	dir, err := templateFiles.ReadDir(".")
	if err != nil {
		return nil, fmt.Errorf("Read embedded templates dir: %w", err)
	}
	for _, f := range dir {
		if f.IsDir() {
			continue
		}
		baseName := strings.TrimSuffix(filepath.Base(f.Name()), filepath.Ext(f.Name()))
		content, err := templateFiles.ReadFile(f.Name())
		if err != nil {
			return nil, fmt.Errorf("Read embedded template %q: %w", f.Name(), err)
		}
		templates[baseName] = template.Must(template.New(baseName).Funcs(funcMap).Parse(string(content)))
	}
	return templates, nil
}

type SubrecordInfo struct {
	Tag      string
	Template string
	Comment  string
}

const headerTemplate = `// Code generated by generator/gen.go; DO NOT EDIT.
package {{.PackageName}}

import (
    "github.com/ernmw/omwpacker/esm"
    "github.com/ernmw/omwpacker/esm/internal/util"
    "bytes"
	"encoding/binary"
)
`

func main() {
	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "usage: go run %q <input.json>\n", os.Args[0])
		os.Exit(1)
	}

	inputPath, err := filepath.Abs(os.Args[1])
	if err != nil {
		panic(fmt.Errorf("resolve input path: %w", err))
	}

	data, err := os.ReadFile(inputPath)
	if err != nil {
		panic(fmt.Errorf("read %q: %w", inputPath, err))
	}

	// Parse JSON into tuples
	var tuples []SubrecordInfo
	if err := json.Unmarshal(data, &tuples); err != nil {
		panic(fmt.Errorf("parse json: %w", err))
	}

	// Determine output path and package name
	outDir := filepath.Dir(inputPath)
	base := strings.TrimSuffix(filepath.Base(inputPath), filepath.Ext(inputPath))
	outputPath := filepath.Join(outDir, base+"_gen.go")

	// Derive package name from directory
	packageName := filepath.Base(outDir)

	// Prepare templates
	headerTmpl := template.Must(template.New("header").Parse(headerTemplate))

	var sb strings.Builder
	if err := headerTmpl.Execute(&sb, map[string]any{"PackageName": packageName}); err != nil {
		panic(err)
	}

	slices.SortFunc(tuples, func(a SubrecordInfo, b SubrecordInfo) int {
		return strings.Compare(fourCC(a.Tag), fourCC(b.Template))
	})

	templates, err := loadTemplates()
	if err != nil {
		panic(err)
	}

	for _, tup := range tuples {
		tmpl, ok := templates[tup.Template]
		if !ok {
			panic(fmt.Errorf("unknown template %q", tup.Template))
		}
		if err := tmpl.Execute(&sb, tup); err != nil {
			panic(err)
		}
	}

	generatedBytes := []byte(strings.TrimSpace(sb.String()) + "\n")
	formattedGeneratedBytes, err := format.Source(generatedBytes)
	if err != nil {
		panic(err)
	}

	// Ensure the output directory exists
	if err := os.MkdirAll(outDir, 0755); err != nil {
		panic(err)
	}

	//     goimports -w your_file.go
	// Apply goimports to the source code
	goImportsSrc, err := imports.Process(filepath.Dir(outputPath), formattedGeneratedBytes, nil)
	if err != nil {
		log.Fatalf("Error processing imports: %v", err)
	}

	// Write the file
	err = os.WriteFile(outputPath, goImportsSrc, 0666)
	if err != nil {
		panic(fmt.Errorf("write output: %w", err))
	}

	fmt.Printf("âœ… Generated: %s\n", outputPath)
}
