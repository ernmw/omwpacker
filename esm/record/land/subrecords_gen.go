// Code generated by generator/gen.go; DO NOT EDIT.
package land

import (
	"bytes"
	"encoding/binary"

	"github.com/ernmw/omwpacker/esm"
)

// Coordinates.
const INTV esm.SubrecordTag = "INTV"

// Coordinates.
type INTVField struct{ X, Y int32 }

func (t *INTVField) Tag() esm.SubrecordTag { return INTV }

func (s *INTVField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.X = int32(binary.LittleEndian.Uint32(sub.Data[0:4]))
	s.Y = int32(binary.LittleEndian.Uint32(sub.Data[4:8]))
	return nil
}

func (s *INTVField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.X); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.Y); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Data types included. If the relevant bit isn't set, the related fields will not be loaded, even if present. 0x01 = Includes VNML, VHGT and WNAM. 0x02 = Includes VCLR. 0x04 = Includes VTEX.
const DATA esm.SubrecordTag = "DATA"

// Data types included. If the relevant bit isn't set, the related fields will not be loaded, even if present. 0x01 = Includes VNML, VHGT and WNAM. 0x02 = Includes VCLR. 0x04 = Includes VTEX.
type DATAField struct{ Value uint32 }

func (t *DATAField) Tag() esm.SubrecordTag { return DATA }

func (s *DATAField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *DATAField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}
