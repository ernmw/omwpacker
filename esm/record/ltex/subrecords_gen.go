// Code generated by generator/gen.go; DO NOT EDIT.
package ltex

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/ernmw/omwpacker/esm"
)

// Texture filename.
const DATA esm.SubrecordTag = "DATA"

// Texture filename.
type DATAField struct{ Value string }

func (t *DATAField) Tag() esm.SubrecordTag { return DATA }

func (s *DATAField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *DATAField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Index.
const INTV esm.SubrecordTag = "INTV"

// Index.
type INTVField struct{ Value uint32 }

func (t *INTVField) Tag() esm.SubrecordTag { return INTV }

func (s *INTVField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *INTVField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// ID string.
const NAME esm.SubrecordTag = "NAME"

// ID string.
type NAMEField struct{ Value string }

func (t *NAMEField) Tag() esm.SubrecordTag { return NAME }

func (s *NAMEField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *NAMEField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}
