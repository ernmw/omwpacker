// Code generated by generator/gen.go; DO NOT EDIT.
package cell

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/ernmw/omwpacker/esm"
	"github.com/ernmw/omwpacker/esm/internal/util"
)

// Name of the cell the reference was moved to (interior cells only) or Faction ID (not light, NPC, or static).
const CNAM esm.SubrecordTag = "CNAM"

// Name of the cell the reference was moved to (interior cells only) or Faction ID (not light, NPC, or static).
type CNAMField struct{ Value string }

func (t *CNAMField) Tag() esm.SubrecordTag { return CNAM }

func (s *CNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *CNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// NPC ID, if applicable (NPC-only).
const ANAM esm.SubrecordTag = "ANAM"

// NPC ID, if applicable (NPC-only).
type ANAMField struct{ Value string }

func (t *ANAMField) Tag() esm.SubrecordTag { return ANAM }

func (s *ANAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *ANAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Coordinates of the cell the reference was moved to (exterior cells only).
const CNDT esm.SubrecordTag = "CNDT"

// Coordinates of the cell the reference was moved to (exterior cells only).
type CNDTField struct{ X, Y int32 }

func (t *CNDTField) Tag() esm.SubrecordTag { return CNDT }

func (s *CNDTField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.X = int32(binary.LittleEndian.Uint32(sub.Data[0:4]))
	s.Y = int32(binary.LittleEndian.Uint32(sub.Data[4:8]))
	return nil
}

func (s *CNDTField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.X); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.Y); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Reference ID for a Form Reference.
const FRMR esm.SubrecordTag = "FRMR"

// Reference ID for a Form Reference.
type FRMRField struct{ Value uint32 }

func (t *FRMRField) Tag() esm.SubrecordTag { return FRMR }

func (s *FRMRField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *FRMRField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Reference ID (always the same as the attached FRMR value).
const MVRF esm.SubrecordTag = "MVRF"

// Reference ID (always the same as the attached FRMR value).
type MVRFField struct{ Value uint32 }

func (t *MVRFField) Tag() esm.SubrecordTag { return MVRF }

func (s *MVRFField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *MVRFField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Cell Travel Destination (Rotations are in radians).
const DODT esm.SubrecordTag = "DODT"

// Cell Travel Destination (Rotations are in radians).
type DODTField struct {
	PosX float32
	PosY float32
	PosZ float32
	RotX float32
	RotY float32
	RotZ float32
}

func (t *DODTField) Tag() esm.SubrecordTag { return DODT }

func (s *DODTField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.PosX = util.BytesToFloat32(sub.Data[0:4])
	s.PosY = util.BytesToFloat32(sub.Data[4:8])
	s.PosZ = util.BytesToFloat32(sub.Data[8:12])
	s.RotX = util.BytesToFloat32(sub.Data[12:16])
	s.RotY = util.BytesToFloat32(sub.Data[16:20])
	s.RotZ = util.BytesToFloat32(sub.Data[20:24])
	return nil
}

func (s *DODTField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.PosX); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.PosY); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.PosZ); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.RotX); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.RotY); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.RotZ); err != nil {
		return nil, err
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Value (uint32).
const NAM9 esm.SubrecordTag = "NAM9"

// Value (uint32).
type NAM9Field struct{ Value uint32 }

func (t *NAM9Field) Tag() esm.SubrecordTag { return NAM9 }

func (s *NAM9Field) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *NAM9Field) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Map color (exterior and like-exterior only).
const NAM5 esm.SubrecordTag = "NAM5"

// Map color (exterior and like-exterior only).
type NAM5Field struct {
	R uint8
	G uint8
	B uint8
}

func (t *NAM5Field) Tag() esm.SubrecordTag { return NAM5 }

func (s *NAM5Field) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.R = sub.Data[0]
	s.G = sub.Data[1]
	s.B = sub.Data[2]
	return nil
}

func (s *NAM5Field) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: []byte{s.R, s.G, s.B, 0}}, nil
}

// Remaining usage. uint32 - health remaining (weapons and armor). uint32 - uses remaining (locks, probes, repair items). float32 - time remaining (lights).
const INTV esm.SubrecordTag = "INTV"

// Remaining usage. uint32 - health remaining (weapons and armor). uint32 - uses remaining (locks, probes, repair items). float32 - time remaining (lights).
type INTVField struct{ Value uint32 }

func (t *INTVField) Tag() esm.SubrecordTag { return INTV }

func (s *INTVField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *INTVField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Reference position (Rotations are in radians).
const DATAFormReference esm.SubrecordTag = "DATA"

// Reference position (Rotations are in radians).
type DATAFormReferenceField struct {
	PosX float32
	PosY float32
	PosZ float32
	RotX float32
	RotY float32
	RotZ float32
}

func (t *DATAFormReferenceField) Tag() esm.SubrecordTag { return DATAFormReference }

func (s *DATAFormReferenceField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.PosX = util.BytesToFloat32(sub.Data[0:4])
	s.PosY = util.BytesToFloat32(sub.Data[4:8])
	s.PosZ = util.BytesToFloat32(sub.Data[8:12])
	s.RotX = util.BytesToFloat32(sub.Data[12:16])
	s.RotY = util.BytesToFloat32(sub.Data[16:20])
	s.RotZ = util.BytesToFloat32(sub.Data[20:24])
	return nil
}

func (s *DATAFormReferenceField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.PosX); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.PosY); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.PosZ); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.RotX); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.RotY); err != nil {
		return nil, err
	}
	if err := binary.Write(buff, binary.LittleEndian, s.RotZ); err != nil {
		return nil, err
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Region name (exterior and like-exterior only).
const RGNN esm.SubrecordTag = "RGNN"

// Region name (exterior and like-exterior only).
type RGNNField struct{ Value string }

func (t *RGNNField) Tag() esm.SubrecordTag { return RGNN }

func (s *RGNNField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *RGNNField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Lock difficulty (uint32).
const FLTV esm.SubrecordTag = "FLTV"

// Lock difficulty (uint32).
type FLTVField struct{ Value uint32 }

func (t *FLTVField) Tag() esm.SubrecordTag { return FLTV }

func (s *FLTVField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *FLTVField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Trap name.
const TNAM esm.SubrecordTag = "TNAM"

// Trap name.
type TNAMField struct{ Value string }

func (t *TNAMField) Tag() esm.SubrecordTag { return TNAM }

func (s *TNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *TNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Key name.
const KNAM esm.SubrecordTag = "KNAM"

// Key name.
type KNAMField struct{ Value string }

func (t *KNAMField) Tag() esm.SubrecordTag { return KNAM }

func (s *KNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *KNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Faction rank (uint32).
const INDX esm.SubrecordTag = "INDX"

// Faction rank (uint32).
type INDXField struct{ Value uint32 }

func (t *INDXField) Tag() esm.SubrecordTag { return INDX }

func (s *INDXField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *INDXField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Cell Name. Unlike other NAME fields, this is the localized, human-readable name of the cell, not a language-agnostic ID string. Exterior regions are mostly empty strings; for these, the region name is used in the Construction Set.
const NAME esm.SubrecordTag = "NAME"

// Cell Name. Unlike other NAME fields, this is the localized, human-readable name of the cell, not a language-agnostic ID string. Exterior regions are mostly empty strings; for these, the region name is used in the Construction Set.
type NAMEField struct{ Value string }

func (t *NAMEField) Tag() esm.SubrecordTag { return NAME }

func (s *NAMEField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *NAMEField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Count of Temporary Children.
const NAM0 esm.SubrecordTag = "NAM0"

// Count of Temporary Children.
type NAM0Field struct{ Value uint32 }

func (t *NAM0Field) Tag() esm.SubrecordTag { return NAM0 }

func (s *NAM0Field) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = binary.LittleEndian.Uint32(sub.Data[0:4])
	return nil
}

func (s *NAM0Field) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Enchantment charge (charged items with non-zero charges), a float32.
const XCHG esm.SubrecordTag = "XCHG"

// Enchantment charge (charged items with non-zero charges), a float32.
type XCHGField struct{ Value float32 }

func (t *XCHGField) Tag() esm.SubrecordTag { return XCHG }

func (s *XCHGField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = util.BytesToFloat32(sub.Data[0:4])
	return nil
}

func (s *XCHGField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Reference is disabled flag (always 0, present if the relevant flag is set in the header).
const ZNAM esm.SubrecordTag = "ZNAM"

// Reference is disabled flag (always 0, present if the relevant flag is set in the header).
type ZNAMField struct{ Value uint8 }

func (t *ZNAMField) Tag() esm.SubrecordTag { return ZNAM }

func (s *ZNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = sub.Data[0]
	return nil
}

func (s *ZNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: []byte{s.Value}}, nil
}

// Reference's scale, if applicable and not 1.0.
const XSCL esm.SubrecordTag = "XSCL"

// Reference's scale, if applicable and not 1.0.
type XSCLField struct{ Value float32 }

func (t *XSCLField) Tag() esm.SubrecordTag { return XSCL }

func (s *XSCLField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = util.BytesToFloat32(sub.Data[0:4])
	return nil
}

func (s *XSCLField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// Reference blocked flag (always 0, present if Blocked is set in the header).
const UNAM esm.SubrecordTag = "UNAM"

// Reference blocked flag (always 0, present if Blocked is set in the header).
type UNAMField struct{ Value uint8 }

func (t *UNAMField) Tag() esm.SubrecordTag { return UNAM }

func (s *UNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = sub.Data[0]
	return nil
}

func (s *UNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: []byte{s.Value}}, nil
}

// Water height (interior only).
const WHGT esm.SubrecordTag = "WHGT"

// Water height (interior only).
type WHGTField struct{ Value float32 }

func (t *WHGTField) Tag() esm.SubrecordTag { return WHGT }

func (s *WHGTField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}
	s.Value = util.BytesToFloat32(sub.Data[0:4])
	return nil
}

func (s *WHGTField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	buff := new(bytes.Buffer)

	if err := binary.Write(buff, binary.LittleEndian, s.Value); err != nil {
		return nil, err
	}
	return &esm.Subrecord{Tag: s.Tag(), Data: buff.Bytes()}, nil
}

// ID of soul in gem (soul gems only).
const XSOL esm.SubrecordTag = "XSOL"

// ID of soul in gem (soul gems only).
type XSOLField struct{ Value string }

func (t *XSOLField) Tag() esm.SubrecordTag { return XSOL }

func (s *XSOLField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *XSOLField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Cell name for previous DODT, if interior.
const DNAM esm.SubrecordTag = "DNAM"

// Cell name for previous DODT, if interior.
type DNAMField struct{ Value string }

func (t *DNAMField) Tag() esm.SubrecordTag { return DNAM }

func (s *DNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *DNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}

// Global variable name.
const BNAM esm.SubrecordTag = "BNAM"

// Global variable name.
type BNAMField struct{ Value string }

func (t *BNAMField) Tag() esm.SubrecordTag { return BNAM }

func (s *BNAMField) Unmarshal(sub *esm.Subrecord) error {
	if s == nil || sub == nil {
		return esm.ErrArgumentNil
	}

	if len(sub.Data) == 0 {
		return fmt.Errorf("zstring subrecord has no data")
	}
	if sub.Data[len(sub.Data)-1] != 0 {
		return fmt.Errorf("zstring subrecord not null-terminated")
	}
	s.Value = string(sub.Data[:len(sub.Data)-1])

	return nil
}

func (s *BNAMField) Marshal() (*esm.Subrecord, error) {
	if s == nil {
		return nil, nil
	}

	return &esm.Subrecord{Tag: s.Tag(), Data: append([]byte(s.Value), 0)}, nil
}
